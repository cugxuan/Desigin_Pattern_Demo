# Design_Pattern_Demo
23种经典的设计模式的demo，使用java语言实现

[github地址](https://github.com/cugxuan/Design_Pattern_Demo)
[MyBlog](http://cugxuan.coding.me/)

# 创建型模式(5种)
用来创建对象的模式，抽象了实例化过程 

工厂模式：父类负责定义创建对象的公共接口，而子类则负责生成具体对象，将类的实例化操作延迟到子类中完成

抽象工厂模式：为一个产品族提供统一的创建接口。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类

单件（Singleton—单例）模式：保证一个类有且仅有一个实例，提供一个全局访问点

生成器（Builder-建造者）模式：将复杂对象创建与表示分离，同样的创建过程可创建不同的表示。允许用户通过指定复杂对象类型和内容来创建对象，用户不需要知道对象内部的具体构建细节

原型（Prototype）模式：通过“复制”一个已经存在的实例来返回新的实例（不新建实例）。被复制的实例就是“原型”，这个原型是可定制的。原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据

```
1.简单工厂模式1_SimpleFactory
2.工厂方法模式2_FactoryFunction
3.抽象工厂模式3_AbstractFactory
4.单例模式4_Singleton
5.建造者模式5_Builder
6.原型模式6_Prototype
```

---
# 结构型模式(7种)
结构型模式讨论的是类和对象的结构，它采用继承机制来组合接口或实现（类结构型模式），或者通过组合一些对象来实现新的功能（对象结构型模式）

组合（Composite）模式：定义一个接口，使之用于单一对象，也可以应用于多个单一对象组成的对象组

装饰（Decorator）模式：给对象动态添加额外的职责，就好像给一个物体加上装饰物，完善其功能

代理（Proxy）模式：在软件系统中，有些对象有时候由于跨越网络或者其他障碍，而不能够或者不想直接访问另一个对象，直接访问会给系统带来不必要的复杂性，这时候可以在客户程序和目标对象之间增加一层中间层，让代理对象来代替目标对象打点一切，这就是代理（Proxy）模式

享元（Flyweight）模式：Flyweight是一个共享对象，它可以同时在不同上下文（Context）使用

外观（Facade）模式：外观模式为子系统提供了一个更高层次、更简单的接口，从而降低了子系统的复杂度，使子系统更易于使用和管理。外观承担了子系统中类交互的责任

桥梁（Bridge）模式：桥梁模式的用意是将问题的抽象和实现分离开来实现，通过用聚合代替继承来解决子类爆炸性增长的问题

适配器(Adapter)模式：将一个类的接口适配成用户所期待的接口。一个适配器允许因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包装在一个已存在的类中 

```
7.组合模式7_Composite
8.装饰模式8_Decorator
9.代理模式9_Proxy
10.享元模式10_Flyweight
11.外观模式11_Facade
12.桥接模式12_Bridge
13.适配器模式13_Adapter
```

# 行为型模式(11种)
着力解决的是类实体之间的通讯关系，希望以面向对象的方式描述一个控制流程

模版（Template ） 模式：定义了一个算法步骤，并允许子类为一个或多个步骤提供实现。子类在不改变算法架构的情况下，可重新定义算法中某些步骤

观察者（Observer）模式：定义了对象之间一对多的依赖，当这个对象的状态发生改变的时候，多个对象会接受到通知，有机会做出反馈

迭代子（Iterator）模式：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示

责任链（Chain of Responsibility）模式：很多对象由每一个对象对其下一个对象的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使系统可以在不影响客户端的情况下动态的重新组织链和分配责任

备忘录（Memento）模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态

命令（Command）模式：将请求及其参数封装成一个对象，作为命令发起者和接收者的中介，可以对这些请求排队或记录请求日志，以及支持可撤销操作

状态（State）模式：允许一个“对象”在其内部状态改变的时候改变其行为，即不同的状态，不同的行为

访问者（Visitor）模式：表示一个作用于某对象结构中的各元素的操作。可以在不改变各元素的类的前提下定义作用于这些元素的新操作

解释器(Interpreter) 模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子

中介者（Mediator）模式：用一个中介对象来封装一系列的对象交互

策略（Strategy）模式：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。策略模式使这些算法在客户端调用它们的时候能够互不影响地变化

```
14.模板模式14_Template
15.观察者模式15_Observer
16.迭代子模式16_Iterator
17.责任链模式17_Chain_of_Responsibility
18.备忘录模式18_Memento
19.命令模式19_Command
20.状态模式20_State
21.访问者模式21_Visitor
22.解释器模式22_Interpreter
23.中介者模式23_Mediator  //调停者
24.策略模式24_Strategy
```